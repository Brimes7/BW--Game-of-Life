{"version":3,"sources":["logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","App","canvasi","useRef","currentBlock","running","useState","blocky","setBlocky","blockyii","setBlockyii","rows","setRows","columns","setColumns","generation","setGeneration","drawBox","blocks","context","current","getContext","i","z","alive","fillStyle","fillRect","useEffect","push","blocking","gameOfLife","gameBlock","nextBlock","liveBlocks","j","k","e","requestAnimationFrame","changeBoard","target","name","value","className","onChange","onClick","Math","random","either","x","floor","clientX","currentTarget","offsetLeft","y","clientY","offsetTop","console","log","ref","width","height","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.48ed3d9e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { useRef, useEffect, useState } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\n\nfunction App() {\n    const canvasi = useRef()\n    const currentBlock = useRef()\n    const running = useRef()\n\n    const [blocky, setBlocky] = useState([])\n    const [blockyii, setBlockyii] = useState([])\n    const [rows, setRows] = useState(25)\n    const [columns, setColumns] = useState(25)\n    const [generation, setGeneration] = useState(0)\n\n    const drawBox = (blocks)=>{\n        const context = canvasi.current.getContext(\"2d\")\n\n        for(let i = 0; i < rows; i ++){\n\n            for (let z = 0; z < columns; z ++){\n                if (blocks[i][z].alive){\n                    context.fillStyle=\"white\"\n                }\n                else{\n                    context.fillStyle=\"blue\"\n                }\n                context.fillRect(i*10, z*10, 10, 10);\n            }\n        }\n\n    }\n    useEffect(()=> {\n        //creating our array of elements - PLACEHOLDERS\n        for(let i = 0; i < rows; i ++){\n            blocky.push([])\n            blockyii.push([])\n            //context.fillRect(i*10, 20, 10, 10);\n            for (let z = 0; z < columns; z ++){\n                const blocking = {alive: false}\n                blocky[i].push(blocking)\n                blockyii[i].push({...blocking})\n            }\n        }\n        drawBox(blockyii)\n        currentBlock.current=\"1\"\n        setBlocky(blocky)\n        setBlockyii(blockyii)\n    },[rows, columns])\n\n    const clicki = (either)=> {\n        debugger;\n        if(running.current){\n            return\n        }\n    let x = Math.floor((either.clientX-either.currentTarget.offsetLeft)/10);\n    let y = Math.floor((either.clientY-either.currentTarget.offsetTop)/10);\n\n    blocky[x][y].alive=!blocky[x][y].alive\n        console.log(blocky)\n        drawBox(blocky);\n    }\n\n    const gameOfLife = ()=> {\n        let gameBlock = blocky\n        let nextBlock = blockyii\n        if(currentBlock.current===\"2\"){\n            gameBlock = blockyii;\n            nextBlock = blocky;\n        }\n        for(let i = 0; i < rows; i ++){\n            for(let z = 0; z < columns; z ++){\n                let liveBlocks = 0;\n                for(let j = (i-1); j < (i + 2); j ++){\n                    for(let k = (z-1); k < (z + 2); k ++){\n                        if(j === i && k === z){\n                            continue;\n                        }\n                        try{\n                        if(gameBlock[j][k] && gameBlock[j][k].alive){\n                            liveBlocks ++;\n                        }}catch(e){\n\n                        }\n                    }\n                }\n                if (gameBlock[i][z].alive){\n                   if(liveBlocks <2 || liveBlocks > 3){\n                       nextBlock[i][z].alive = false\n                   }\n                   else{\n                       nextBlock[i][z].alive = true\n                   }\n                }\n                else{\n                    if(liveBlocks === 3){\n                        nextBlock[i][z].alive = true\n                    }\n                    else{\n                        nextBlock[i][z].alive = false\n                    }\n                }\n            }\n        }\n        drawBox(nextBlock)\n        if(currentBlock.current === \"2\"){\n            currentBlock.current = \"1\";\n        }\n        else{\n            currentBlock.current = \"2\";\n        }\n        if(running.current){\n            // window.setTimeout(()=> {\n            //     requestAnimationFrame(gameOfLife)\n            // }, 250)\n            requestAnimationFrame(gameOfLife)\n        }\n        setGeneration((generation)=> {\n            return generation +1;\n        })\n    }\n    const changeBoard = (e)=> {\n        if(running.current){\n            return\n        }\n        if(e.target.name===\"rows\"){\n            setRows(e.target.value)\n        }\n        else{\n            setColumns(e.target.value)\n        }\n    }\n    const startGame = ()=> {\n        running.current = true;\n        requestAnimationFrame(gameOfLife)\n    }\n    const stopGame = ()=> {\n        running.current = false;\n    }\n    const clearBoard = ()=> {\n        running.current = false;\n        for(let i = 0; i < rows; i ++){\n            for(let z = 0; z < rows; z ++){\n                blocky[i][z].alive = false\n                blockyii[i][z].alive = false\n            }\n        }\n        drawBox(blocky)\n        setGeneration(0)\n    }\n    const randomizeBoard = ()=> {\n        for(let i = 0; i < rows; i ++){\n            for(let z = 0; z < rows; z ++){\n                if (Math.random() < .4){\n                    blocky[i][z].alive = true;\n                }\n                else{\n                    blocky[i][z].alive = false;\n                }\n            }\n        }\n        drawBox(blocky)\n        currentBlock.current = \"1\"\n    }\n\n  return (\n    <div className=\"bigContainer\">\n      <header className=\"App-header\">\n          <div className=\"insideAppHeader\">\n\n              <label className=\"label\">\n                Rows:\n                <input name={\"rows\"} value={rows} onChange={changeBoard}/>\n              </label>\n\n              <label className=\"label\">\n                  Columns:\n                  <input name={\"col\"} value={columns} onChange={changeBoard}/>\n              </label>\n\n          </div>\n          <div className=\"headerButtons\">\n              {/*//Will need to add styling  to this later*/}\n              <button onClick={randomizeBoard}>Randomize Board</button>\n              <button onClick={startGame}>Start</button>\n              <button onClick={stopGame}>Stop</button>\n              <button onClick={clearBoard}>Clear Board</button>\n          </div>\n          Generation: {generation}\n        <canvas onClick={clicki} ref={canvasi} width={(columns * 10) + \"px\"} height={(rows * 10) +\"px\"}/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}